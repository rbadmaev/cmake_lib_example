### Плюсы:
- Простота
- Для работы клиента достаточно передать ему один аргумент - путь до каталога в который была установлена библиотека
- Используется только CMake
    - Библиотека собирается тремя стандартными командами cmake

        ```sh
        cmake -DCMAKE_INSTALL_PREFIX=installDir libraryDir
        cmake --build .
        cmake --install .
        ```
    - Клинет тоже собирается стандартными командами cmake, но с передачей доп.аргумента

        ```sh
        cmake -DCMAKE_PREFIX_PATH=installDir clientDir
        cmake --build .
        ```
- Несколько бинарных файлов в библиотеке не являются проблемой
- Библиотека определяет структуру экспорта:
    - Можно разделить интерфейсные и приватные заголовочные файлы
    - Это разделение не влияет на структуру файлов в проекте библиотеки, а определяется только на шаге установки
- Передача пути до библиотеки идет через стандартную переменную для CMake `CMAKE_PREFIX_PATH`
- Клиентский проект не должен знать структуру экспорта библиотеки. Он может использовать экспортиеруемый библиотекой таргет.
- Клиентский проект не должен знать тип библиотеки. Все определяется самой библиотекой.
- Сборочные таргеты библиотекни не связаны с экспортируемыми таргетам. Библиотека может выставлять любой интрефейс по таргетам без привязки к внутренней реализации.
- Библиотека может выставить несколько таргетов, разделив заголовочные файлы и файлы библиотек для разных таргетов.
- Реализовано версионирование
- Версии берутся из описания проекта в CMAKE
- Перемещаемые артефакты. Для передачи пакета достаточно скопировать папку в которую была совершена установка.
- Репозиторий собирает один пакет, который может содержать несколько таргетов.
- Требуемые действия выделены в один подключаемый cmake файл, который может быть переиспользован.
    Использование в библиотеках чуть сложнее чем в предыдущем варианте, но все еще достаточно простое. 
    Для использования необходимо:
    - Включить файл `exportPackage.cmake`.
    - Создать новый пакет вызывав функцию `createPackage(<packageName>, <packageVersion>)`.
        Хорошей идеей будет использовать имя и версию проекта `createPackage(${PROJECT_NAME}, ${PROJECT_VERSION})`, если подкаталоги не создают новых проектов.
    - Для каждого экспортируемого target-а вызвать функцию `exportTarget(<packageName>, <targetName>)`. В данной реализации это могут быть только библиотеки, но возможно расширение и на исполняемые файлы.
    - После добавления всех экспортируемых таргетов вызвать функцию `exportPackage(<packageName>)`. Она, собственно, и создаст фалы пакета и добавит их в шаг по установке.
- Возможность создания нескольких пакетов параллельно, и распределения таргетов по ним    

### Минусы:
- Необходимо передавать клиенту путь до каталога в который установлена библиотека.
- Клиент должен знать список таргетов экспортируемых библиотекой.
- Нет готового способа передачи исходников/бинарников между машинами, и учета двоичной совместимости
- Ручное управление версиями.
- Номера версий могут быть только цифровыми. Несовместимо с `git describe`
